<!-- TOC -->

- [1. 简介](#1-简介)
- [2. 静态方法](#2-静态方法)
- [3. 实例属性的新写法](#3-实例属性的新写法)
- [4. 静态属性](#4-静态属性)
- [5. 私有方法和私有属性](#5-私有方法和私有属性)
- [6. new.target 属性](#6-newtarget-属性)

<!-- /TOC -->

# 1. 简介

类的内部所有定义的方法，都是不可枚举的，这一点与 ES5 的行为不一致。

constructor 方法

必须使用 `new` 方法调用

取值函数（getter）和存值函数（setter）

类的属性名，可以采用表达式。类也可以使用表达式的形式定义。

类和模块的内部，默认就是严格模式，不存在变量提升。

# 2. 静态方法

`static` 关键字，父类的静态方法，可以被子类继承。

# 3. 实例属性的新写法

所有实例对象自身的属性都定义在类的头部，看上去比较整齐

# 4. 静态属性

```js
class Foo {
}

Foo.prop = 1;
Foo.prop // 1
```
目前，只有这种写法可行.

# 5. 私有方法和私有属性

1⃣️ 命名上用 `_` 开头加以区别

2⃣️ 将私有方法移出模块
```js
class Widget {
  foo (baz) {
    bar.call(this, baz);
  }

  // ...
}

function bar(baz) {
  return this.snaf = baz;
}
```
3⃣️ 利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值。

# 6. new.target 属性

如果构造函数不是通过 `new` 命令或 `Reflect.construct()` 调用的，`new.target` 会返回 `undefined`，

子类继承父类时，`new.target` 会返回子类。